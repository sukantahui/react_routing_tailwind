<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Module 11 — ES6+ Features Test Part 1 | let/const & Template Literals | Coder & AccoTax</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <style>
    :root{
      --bg:#020617;
      --accent:#38bdf8;
      --accent2:#a855f7;
      --accent3:#22c55e;
      --text:#e5e7eb;
      --muted:#9ca3af;
      --border:#1f2937;
    }

    *{box-sizing:border-box;margin:0;padding:0;}

    body{
      margin:0;
      padding:20px;
      font-family:system-ui,-apple-system,"Segoe UI",Roboto,sans-serif;
      background:radial-gradient(circle at top,#0f172a,#020617 55%,#000);
      color:var(--text);
      line-height:1.7;
    }

    .page{max-width:1100px;margin:auto;}

    h1,h2,h3{margin:0;padding:0;}

    .intro-card{
      background:rgba(15,23,42,0.96);
      border-radius:22px;
      padding:18px 20px;
      margin-bottom:22px;
      border:1px solid rgba(56,189,248,0.45);
      box-shadow:0 0 28px rgba(56,189,248,0.18);
    }

    .intro-title{
      font-size:2rem;
      background:linear-gradient(90deg,#38bdf8,#a855f7,#22c55e);
      -webkit-background-clip:text;
      color:transparent;
      margin-bottom:6px;
    }

    .intro-sub{color:var(--muted);font-size:0.98rem;}

    .card{
      background:rgba(15,23,42,0.96);
      border-radius:20px;
      border:1px solid rgba(148,163,184,0.35);
      padding:18px 18px 16px;
      margin-bottom:22px;
      box-shadow:0 0 24px rgba(15,23,42,0.85);
    }

    .card h2{
      font-size:1.2rem;
      color:#e0f2fe;
      margin-bottom:8px;
    }

    .qbox{
      background:rgba(15,23,42,0.92);
      padding:14px 14px 12px;
      border-radius:14px;
      border:1px solid rgba(56,189,248,0.45);
      box-shadow:0 0 18px rgba(56,189,248,0.18);
      margin-bottom:14px;
      font-size:0.95rem;
    }

    pre{
      background:#020617;
      border-radius:10px;
      padding:10px 12px;
      border:1px solid rgba(30,64,175,0.7);
      overflow-x:auto;
      font-size:0.85rem;
      margin:8px 0;
    }

    code{font-family:"Fira Code",Consolas,monospace;}

    button{
      margin-top:8px;
      padding:7px 13px;
      border-radius:999px;
      border:none;
      cursor:pointer;
      font-weight:600;
      font-size:0.85rem;
      background:linear-gradient(90deg,#38bdf8,#a855f7);
      color:#000;
      box-shadow:0 0 16px rgba(56,189,248,0.45);
      transition:0.25s;
    }
    button:hover{
      transform:scale(1.06) translateY(-1px);
      box-shadow:0 0 22px rgba(168,85,247,0.55);
    }

    .answer{
      display:none;
      margin-top:8px;
      padding:10px 11px;
      border-radius:10px;
      background:rgba(22,163,74,0.16);
      border-left:4px solid #22c55e;
      font-size:0.9rem;
    }

    .footer{
      margin-top:28px;
      padding:18px;
      border-radius:22px;
      background:linear-gradient(120deg,rgba(15,23,42,0.97),rgba(15,23,42,0.92));
      border:1px solid rgba(56,189,248,0.4);
      font-size:0.86rem;
    }
    .org-grid{
      display:grid;
      grid-template-columns:2fr 1.4fr;
      gap:12px;
    }
    @media(max-width:700px){.org-grid{grid-template-columns:1fr;}}
    .org-name{font-weight:700;}
    .org-sub{color:var(--muted);margin-bottom:6px;}
    .org-small{margin-top:8px;font-size:0.78rem;color:#64748b;}
    .footer a{color:var(--accent);text-decoration:none;}
    .footer a:hover{text-decoration:underline;}
  </style>

  <script>
    function toggleAns(id){
      const ans = document.getElementById(id);
      if(!ans) return;
      ans.style.display = (ans.style.display === "block") ? "none" : "block";
    }
  </script>
</head>

<body>
<div class="page">

  <!-- INTRO -->
  <div class="intro-card">
    <h1 class="intro-title">
      Module 11 — ES6+ Features  
      <span style="font-size:1.05rem;display:block;margin-top:4px;">
        Test Part 1 · <code>let</code>/<code>const</code>, Scope &amp; Template Literals
      </span>
    </h1>
    <p class="intro-sub">
      25 carefully designed questions focused on <strong>let/const vs var</strong>, 
      <strong>block scope</strong>, <strong>hoisting</strong>, and 
      <strong>template literals</strong> with real-world patterns used in modern JavaScript.
    </p>
  </div>

  <!-- SECTION A -->
  <div class="card">
    <h2>Section A — Output &amp; Short Logic (Scope &amp; let/const)</h2>

    <!-- Q1 -->
    <div class="qbox">
      <b>Q1.</b> What will be the output?
      <pre><code>let x = 1;
if (true) {
  let x = 2;
  console.log(x);
}
console.log(x);</code></pre>

      <button onclick="toggleAns('a1')">Show Answer &amp; Explanation</button>
      <div class="answer" id="a1">
        <b>Answer:</b><br>
        <code>2</code><br>
        <code>1</code><br>
        <b>Explanation:</b> <code>let</code> is block-scoped. The inner <code>x</code> (value 2) is a
        different variable from the outer <code>x</code> (value 1).
      </div>
    </div>

    <!-- Q2 -->
    <div class="qbox">
      <b>Q2.</b> What happens when this code runs?
      <pre><code>console.log(a);
var a = 10;</code></pre>

      <button onclick="toggleAns('a2')">Show Answer &amp; Explanation</button>
      <div class="answer" id="a2">
        <b>Answer:</b> <code>undefined</code><br>
        <b>Explanation:</b> <code>var</code> declarations are hoisted and initialised with
        <code>undefined</code>. So the variable exists, but its value is <code>undefined</code>
        at the time of the <code>console.log</code>.
      </div>
    </div>

    <!-- Q3 -->
    <div class="qbox">
      <b>Q3.</b> What happens here?
      <pre><code>console.log(b);
let b = 20;</code></pre>

      <button onclick="toggleAns('a3')">Show Answer &amp; Explanation</button>
      <div class="answer" id="a3">
        <b>Answer:</b> A <code>ReferenceError</code> is thrown.<br>
        <b>Explanation:</b> <code>let</code> is hoisted but not initialised; it stays in the
        “temporal dead zone” until its declaration line is executed. Accessing it before that
        throws an error.
      </div>
    </div>

    <!-- Q4 -->
    <div class="qbox">
      <b>Q4.</b> Predict the output:
      <pre><code>var x = 5;
function test() {
  var x = 10;
  if (true) {
    var x = 20;
    console.log("Inside if:", x);
  }
  console.log("Inside function:", x);
}
test();
console.log("Global:", x);</code></pre>

      <button onclick="toggleAns('a4')">Show Answer &amp; Explanation</button>
      <div class="answer" id="a4">
        <b>Answer:</b><br>
        <code>Inside if: 20</code><br>
        <code>Inside function: 20</code><br>
        <code>Global: 5</code><br>
        <b>Explanation:</b> With <code>var</code>, the function has a single <code>x</code>.
        The <code>if</code> does not create a new scope, so the same <code>x</code> becomes 20.
        The global <code>x</code> remains 5.
      </div>
    </div>

    <!-- Q5 -->
    <div class="qbox">
      <b>Q5.</b> What will be printed?
      <pre><code>let count = 0;
for (let i = 0; i &lt; 3; i++) {
  count += i;
}
console.log(count);</code></pre>

      <button onclick="toggleAns('a5')">Show Answer &amp; Explanation</button>
      <div class="answer" id="a5">
        <b>Answer:</b> <code>3</code><br>
        <b>Explanation:</b> Loop adds 0 + 1 + 2 to <code>count</code>. Final value = 3.
      </div>
    </div>

    <!-- Q6 -->
    <div class="qbox">
      <b>Q6.</b> What happens here?
      <pre><code>const x = 10;
x = 20;
console.log(x);</code></pre>

      <button onclick="toggleAns('a6')">Show Answer &amp; Explanation</button>
      <div class="answer" id="a6">
        <b>Answer:</b> TypeError at runtime.<br>
        <b>Explanation:</b> <code>const</code> variables cannot be re-assigned after their initial value.
      </div>
    </div>

    <!-- Q7 -->
    <div class="qbox">
      <b>Q7.</b> What will be logged?
      <pre><code>const student = { name: "Amit" };
student.name = "Neha";
console.log(student.name);</code></pre>

      <button onclick="toggleAns('a7')">Show Answer &amp; Explanation</button>
      <div class="answer" id="a7">
        <b>Answer:</b> <code>"Neha"</code><br>
        <b>Explanation:</b> <code>const</code> prevents re-assignment of the variable binding
        (you cannot do <code>student = {...}</code>), but the object <em>properties</em> can still
        be changed.
      </div>
    </div>

    <!-- Q8 -->
    <div class="qbox">
      <b>Q8.</b> Output?
      <pre><code>for (var i = 0; i &lt; 3; i++) {}
console.log(i);</code></pre>

      <button onclick="toggleAns('a8')">Show Answer &amp; Explanation</button>
      <div class="answer" id="a8">
        <b>Answer:</b> <code>3</code><br>
        <b>Explanation:</b> <code>var i</code> is function-scoped (or global here), so after
        the loop ends <code>i</code> is still available with value 3.
      </div>
    </div>

    <!-- Q9 -->
    <div class="qbox">
      <b>Q9.</b> Output?
      <pre><code>for (let j = 0; j &lt; 3; j++) {}
console.log(typeof j);</code></pre>

      <button onclick="toggleAns('a9')">Show Answer &amp; Explanation</button>
      <div class="answer" id="a9">
        <b>Answer:</b> <code>"undefined"</code> is NOT printed — instead a <code>ReferenceError</code> occurs.<br>
        <b>Explanation:</b> <code>j</code> is block-scoped to the <code>for</code> loop. Outside, it does not exist.
      </div>
    </div>

    <!-- Q10 -->
    <div class="qbox">
      <b>Q10.</b> Predict the output:
      <pre><code>let a = 1;
{
  let a = 2;
  {
    let a = 3;
    console.log(a);
  }
  console.log(a);
}
console.log(a);</code></pre>

      <button onclick="toggleAns('a10')">Show Answer &amp; Explanation</button>
      <div class="answer" id="a10">
        <b>Answer:</b><br>
        <code>3</code><br>
        <code>2</code><br>
        <code>1</code><br>
        <b>Explanation:</b> Each block has its own <code>a</code>. Inner-most is 3, then 2, then 1 in the outer scope.
      </div>
    </div>

  </div><!-- /Section A -->

  <!-- SECTION B -->
  <div class="card">
    <h2>Section B — MCQs on let/const/var, Scope &amp; Hoisting</h2>

    <!-- Q11 -->
    <div class="qbox">
      <b>Q11.</b> Which statement is <strong>true</strong>?
      <br><br>
      A. <code>var</code> is block-scoped, <code>let</code> is function-scoped. <br>
      B. Both <code>var</code> and <code>let</code> are block-scoped. <br>
      C. <code>var</code> is function-scoped, <code>let</code> is block-scoped. <br>
      D. Both are function-scoped.
      <br><br>
      <button onclick="toggleAns('a11')">Show Answer &amp; Explanation</button>
      <div class="answer" id="a11">
        <b>Correct Option:</b> C<br>
        <b>Explanation:</b> <code>var</code> is function-scoped, whereas <code>let</code> and
        <code>const</code> are block-scoped.
      </div>
    </div>

    <!-- Q12 -->
    <div class="qbox">
      <b>Q12.</b> Which variable type is recommended by default in modern JavaScript?
      <br><br>
      A. <code>var</code><br>
      B. <code>let</code><br>
      C. <code>const</code><br>
      D. <code>static</code>
      <br><br>
      <button onclick="toggleAns('a12')">Show Answer &amp; Explanation</button>
      <div class="answer" id="a12">
        <b>Correct Option:</b> C<br>
        <b>Explanation:</b> Use <code>const</code> by default; switch to <code>let</code> only
        when re-assignment is needed.
      </div>
    </div>

    <!-- Q13 -->
    <div class="qbox">
      <b>Q13.</b> Which is a correct summary of the “temporal dead zone” (TDZ)?
      <br><br>
      A. The time before a <code>var</code> is declared. <br>
      B. The time between entering scope and declaration of a <code>let</code>/<code>const</code>, where access throws an error. <br>
      C. A zone where all variables are undefined. <br>
      D. A special memory region for objects only.
      <br><br>
      <button onclick="toggleAns('a13')">Show Answer &amp; Explanation</button>
      <div class="answer" id="a13">
        <b>Correct Option:</b> B<br>
        <b>Explanation:</b> TDZ applies to <code>let</code>/<code>const</code> — the variable is
        in scope but not initialised, so any access causes a <code>ReferenceError</code>.
      </div>
    </div>

    <!-- Q14 -->
    <div class="qbox">
      <b>Q14.</b> Re-declaring a variable with <code>var</code> in the same function:
      <br><br>
      A. Causes a syntax error. <br>
      B. Is allowed, might override the previous value. <br>
      C. Is only allowed in strict mode. <br>
      D. Is never possible.
      <br><br>
      <button onclick="toggleAns('a14')">Show Answer &amp; Explanation</button>
      <div class="answer" id="a14">
        <b>Correct Option:</b> B<br>
        <b>Explanation:</b> <code>var</code> allows re-declaration in the same scope, which can
        cause bugs; <code>let</code>/<code>const</code> do not allow this.
      </div>
    </div>

    <!-- Q15 -->
    <div class="qbox">
      <b>Q15.</b> Which of the following is <strong>not</strong> a good reason to avoid <code>var</code>?
      <br><br>
      A. Function-scoped behaviour can be confusing. <br>
      B. Re-declaration is allowed and error-prone. <br>
      C. Hoisting can lead to unexpected <code>undefined</code>. <br>
      D. <code>var</code> makes code run slower in all cases.
      <br><br>
      <button onclick="toggleAns('a15')">Show Answer &amp; Explanation</button>
      <div class="answer" id="a15">
        <b>Correct Option:</b> D<br>
        <b>Explanation:</b> Performance is not the primary reason; the main issues are
        readability, predictability, and fewer accidental bugs with <code>let</code>/<code>const</code>.
      </div>
    </div>
  </div><!-- /Section B -->

  <!-- SECTION C -->
  <div class="card">
    <h2>Section C — Template Literals &amp; String Practice</h2>

    <!-- Q16 -->
    <div class="qbox">
      <b>Q16.</b> What will be logged?
      <pre><code>const name = "Sukanta";
const course = "ES6+";
const msg = "Hello " + name + ", welcome to " + course + " module!";
console.log(msg);</code></pre>
      Rewrite the same <code>msg</code> using a template literal.
      <br><br>
      <button onclick="toggleAns('a16')">Show Answer &amp; Explanation</button>
      <div class="answer" id="a16">
        <b>Answer:</b><br>
        <code>const msg = `Hello ${name}, welcome to ${course} module!`;</code><br>
        <b>Explanation:</b> Backticks <code>` `</code> allow embedded expressions via
        <code>${...}</code>, replacing manual concatenation.
      </div>
    </div>

    <!-- Q17 -->
    <div class="qbox">
      <b>Q17.</b> What is the output?
      <pre><code>const centre = "Coder &amp; AccoTax";
const city = "Barrackpore";

console.log(`${centre} is located in ${city}.`);</code></pre>

      <button onclick="toggleAns('a17')">Show Answer &amp; Explanation</button>
      <div class="answer" id="a17">
        <b>Answer:</b><br>
        <code>Coder &amp; AccoTax is located in Barrackpore.</code><br>
        <b>Explanation:</b> Template literals interpolate variables directly in the string.
      </div>
    </div>

    <!-- Q18 -->
    <div class="qbox">
      <b>Q18.</b> Predict the output:
      <pre><code>const a = 5;
const b = 3;
console.log(`${a} + ${b} = ${a + b}`);</code></pre>

      <button onclick="toggleAns('a18')">Show Answer &amp; Explanation</button>
      <div class="answer" id="a18">
        <b>Answer:</b> <code>5 + 3 = 8</code><br>
        <b>Explanation:</b> Expressions inside <code>${...}</code> are evaluated; 
        <code>a + b</code> is calculated before being converted to string.
      </div>
    </div>

    <!-- Q19 -->
    <div class="qbox">
      <b>Q19.</b> Choose the correct multi-line template literal:
      <br><br>
      A.
      <pre><code>const text = "Line1
Line2";</code></pre>
      B.
      <pre><code>const text = `Line1
Line2`;</code></pre>
      C.
      <pre><code>const text = 'Line1
Line2';</code></pre>
      D.
      <pre><code>const text = multi("Line1","Line2");</code></pre>
      <button onclick="toggleAns('a19')">Show Answer &amp; Explanation</button>
      <div class="answer" id="a19">
        <b>Correct Option:</b> B<br>
        <b>Explanation:</b> Only backticks <code>` `</code> support natural multi-line strings.
      </div>
    </div>

    <!-- Q20 -->
    <div class="qbox">
      <b>Q20.</b> For a log message in Coder &amp; AccoTax app:
      <pre><code>// Fill the template literal
const moduleName = "Module 11";
const message = /* ??? */;
console.log(message);</code></pre>
      It should print:
      <br>
      <code>Loading Module 11 — ES6+ Features...</code><br><br>
      <button onclick="toggleAns('a20')">Show Answer &amp; Explanation</button>
      <div class="answer" id="a20">
        <b>Sample Answer:</b><br>
        <code>const message = `Loading ${moduleName} — ES6+ Features...`;</code><br>
        <b>Explanation:</b> Use <code>${moduleName}</code> inside backticks to insert the variable.
      </div>
    </div>
  </div><!-- /Section C -->

  <!-- SECTION D -->
  <div class="card">
    <h2>Section D — Conceptual &amp; Short Answer Style</h2>

    <!-- Q21 -->
    <div class="qbox">
      <b>Q21.</b>  
      <b>Question:</b> In modern JavaScript, why is <code>const</code> often preferred over <code>let</code> and <code>var</code>?
      <br><br>
      <button onclick="toggleAns('a21')">Show Sample Answer</button>
      <div class="answer" id="a21">
        <b>Sample Answer:</b><br>
        <code>const</code> clearly communicates that the variable binding will not change,
        making the code easier to reason about. It also avoids accidental re-assignment.
        Compared to <code>var</code>, it is block-scoped and avoids hoisting surprises.
        You then switch to <code>let</code> only when re-assignment is required.
      </div>
    </div>

    <!-- Q22 -->
    <div class="qbox">
      <b>Q22.</b>  
      <b>Question:</b> Explain the main differences between <code>var</code> and <code>let</code>.
      <br><br>
      <button onclick="toggleAns('a22')">Show Sample Answer</button>
      <div class="answer" id="a22">
        <b>Sample Answer:</b><br>
        <ul>
          <li><code>var</code> is function-scoped; <code>let</code> is block-scoped.</li>
          <li><code>var</code> can be re-declared in the same scope; <code>let</code> cannot.</li>
          <li><code>var</code> is hoisted and initialised with <code>undefined</code>; 
              <code>let</code> is hoisted but kept in the temporal dead zone until its declaration line.</li>
        </ul>
      </div>
    </div>

    <!-- Q23 -->
    <div class="qbox">
      <b>Q23.</b>  
      <b>Question:</b> For the JavaScript course at Coder &amp; AccoTax, you want to print:
      <br>
      <code>Welcome Amit, you are enrolled in JavaScript From Basic to Pro at Coder &amp; AccoTax.</code><br>
      Show how you would build this string using a template literal.
      <br><br>
      <button onclick="toggleAns('a23')">Show Sample Answer</button>
      <div class="answer" id="a23">
        <b>Sample Answer:</b><br>
        <pre><code>const name = "Amit";
const course = "JavaScript From Basic to Pro";
const centre = "Coder &amp; AccoTax";

const msg = `Welcome ${name}, you are enrolled in ${course} at ${centre}.`;</code></pre>
      </div>
    </div>

    <!-- Q24 -->
    <div class="qbox">
      <b>Q24.</b>  
      <b>Question:</b> Why are template literals preferred over string concatenation with <code>+</code> 
      when building complex UI messages?
      <br><br>
      <button onclick="toggleAns('a24')">Show Sample Answer</button>
      <div class="answer" id="a24">
        <b>Sample Answer:</b><br>
        Template literals are easier to read and write, especially with many variables or
        multi-line text. They avoid mistakes with quotes and <code>+</code> signs, and allow
        you to embed expressions directly using <code>${...}</code>, which is more expressive
        than manual concatenation.
      </div>
    </div>

    <!-- Q25 -->
    <div class="qbox">
      <b>Q25.</b>  
      <b>Question:</b> A student says: “I’ll use <code>var</code> for all variables; it has worked in
      old JavaScript code, so it’s fine.” As a mentor at Coder &amp; AccoTax, how would you
      briefly guide them towards <code>let</code>/<code>const</code>?
      <br><br>
      <button onclick="toggleAns('a25')">Show Sample Answer</button>
      <div class="answer" id="a25">
        <b>Sample Answer:</b><br>
        I would explain that <code>var</code> still works but has confusing behaviour (function
        scope, hoisting, re-declaration), which can lead to hard-to-find bugs. Modern code
        uses <code>let</code> and <code>const</code> because they are block-scoped and make
        intent clearer. Using them will match current industry standards and make it easier
        to work with modern frameworks like React or Node.js.
      </div>
    </div>

  </div><!-- /Section D -->

  <!-- FOOTER / ORGANISATION DETAILS -->
  <div class="footer">
    <div class="org-grid">
      <div>
        <div class="org-name">Coder &amp; AccoTax</div>
        <div class="org-sub">Coding, Accounts &amp; Taxation Learning Hub</div>
        25(10/A) Shibtala Road, PO – N. C. Pukur, Barrackpore<br>
        West Bengal, India
      </div>
      <div>
        <strong>Website:</strong>
        <a href="https://www.codernaccotax.co.in" target="_blank" rel="noopener noreferrer">
          www.codernaccotax.co.in
        </a><br>
        <strong>Phone:</strong> +91 7003756860<br>
        <strong>Course Author:</strong> Sukanta Hui<br>
        <strong>JavaScript Track:</strong> Module 11 — ES6+ Features · Test Part 1
      </div>
    </div>
    <div class="org-small">
      Use this file as Part 1 of the complete <strong>Module 11 — Modern JavaScript (ES6+)</strong>
      practice test series on your JavaScript course portal.
    </div>
  </div>

</div><!-- /page -->
</body>
</html>
