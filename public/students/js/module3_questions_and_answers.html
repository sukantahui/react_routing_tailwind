<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Java OOP – 100 Questions with Answers & Explanations — Coder &amp; AccoTax</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="description" content="100 expert-level Java OOP questions with detailed answers and explanations. Topics: access modifiers, encapsulation, abstraction, classes, objects, initialization, and constructor chaining. Prepared by Sukanta Hui, Coder & AccoTax." />
  <style>
    :root {
      --bg: #020617;
      --panel: #020617;
      --accent: #38bdf8;
      --accent-soft: rgba(56,189,248,0.16);
      --accent-2: #a855f7;
      --accent-3: #f97316;
      --text: #e5e7eb;
      --muted: #9ca3af;
      --border: #1f2937;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: radial-gradient(circle at top, #1f2937 0, #020617 55%, #000 100%);
      color: var(--text);
      line-height: 1.6;
    }
    .page {
      max-width: 1150px;
      margin: 0 auto;
      padding: 2rem 1rem 3rem;
    }
    header {
      background: linear-gradient(135deg, rgba(56,189,248,0.12), rgba(168,85,247,0.18));
      border-radius: 1.5rem;
      padding: 1.8rem 1.5rem;
      border: 1px solid rgba(148,163,184,0.4);
      box-shadow: 0 20px 45px rgba(15,23,42,0.9);
      backdrop-filter: blur(16px);
      display: flex;
      flex-direction: column;
      gap: 0.8rem;
    }
    @media (min-width: 768px) {
      header {
        padding: 2rem 2rem;
        flex-direction: row;
        align-items: center;
        justify-content: space-between;
      }
    }
    .brand-block {
      display: flex;
      flex-direction: column;
      gap: 0.35rem;
    }
    .badge {
      display: inline-flex;
      align-items: center;
      gap: 0.4rem;
      padding: 0.12rem 0.7rem;
      border-radius: 999px;
      background: rgba(15,23,42,0.96);
      border: 1px solid rgba(148,163,184,0.7);
      font-size: 0.75rem;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: 0.12em;
    }
    .badge-dot {
      width: 0.45rem;
      height: 0.45rem;
      border-radius: 999px;
      background: radial-gradient(circle, #22c55e 0, #166534 50%, #052e16 100%);
      box-shadow: 0 0 0 6px rgba(34,197,94,0.22);
    }
    h1 {
      margin: 0.1rem 0 0.2rem;
      font-size: clamp(1.7rem, 3vw, 2.2rem);
      letter-spacing: 0.02em;
    }
    h1 span {
      background: linear-gradient(120deg, #e5e7eb, #bae6fd, #f9a8d4);
      -webkit-background-clip: text;
      background-clip: text;
      color: transparent;
    }
    .subtitle {
      font-size: 0.94rem;
      color: var(--muted);
    }
    .org {
      font-size: 0.9rem;
      color: var(--muted);
    }
    .org strong {
      color: #e5e7eb;
    }
    .tag-row {
      display: flex;
      flex-wrap: wrap;
      gap: 0.35rem;
      margin-top: 0.3rem;
    }
    .tag {
      font-size: 0.7rem;
      padding: 0.16rem 0.6rem;
      border-radius: 999px;
      background: radial-gradient(circle at top left, rgba(56,189,248,0.22), rgba(15,23,42,0.96));
      border: 1px solid rgba(148,163,184,0.6);
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: 0.12em;
    }
    .contact {
      font-size: 0.85rem;
      color: var(--muted);
      display: flex;
      flex-direction: column;
      gap: 0.2rem;
      margin-top: 0.4rem;
    }
    @media (min-width: 768px) {
      .contact { text-align: right; align-items: flex-end; }
    }
    .contact a {
      color: var(--accent);
      text-decoration: none;
    }
    .contact a:hover { text-decoration: underline; }
    main {
      margin-top: 2rem;
    }
    .panel {
      background: radial-gradient(circle at top left, rgba(56,189,248,0.14), rgba(15,23,42,0.97));
      border-radius: 1.4rem;
      border: 1px solid rgba(30,64,175,0.75);
      padding: 1.4rem 1.3rem 1.6rem;
      box-shadow: 0 18px 40px rgba(15,23,42,0.95);
      position: relative;
      overflow: hidden;
    }
    .panel::before {
      content: "";
      position: absolute;
      inset: -35%;
      background:
        radial-gradient(circle at 0 0, rgba(59,130,246,0.1), transparent 70%),
        radial-gradient(circle at 100% 0, rgba(236,72,153,0.1), transparent 65%);
      opacity: 0.7;
      pointer-events: none;
    }
    .panel-inner {
      position: relative;
      z-index: 1;
    }
    h2 {
      margin-top: 0.4rem;
      margin-bottom: 0.4rem;
      font-size: 1.2rem;
      color: #f9fafb;
      border-left: 3px solid rgba(56,189,248,0.9);
      padding-left: 0.5rem;
    }
    h3 {
      margin-top: 1rem;
      margin-bottom: 0.3rem;
      font-size: 1.02rem;
      color: #e5e7eb;
    }
    p {
      margin: 0.2rem 0 0.6rem;
      font-size: 0.92rem;
      color: var(--text);
    }
    ol {
      margin: 0.3rem 0 0.9rem 1.3rem;
      padding: 0;
      font-size: 0.9rem;
    }
    li { margin-bottom: 0.4rem; }
    .section-header {
      margin-top: 1.1rem;
      padding: 0.45rem 0.65rem;
      border-radius: 0.75rem;
      background: rgba(15,23,42,0.9);
      border: 1px solid rgba(30,64,175,0.85);
      font-size: 0.95rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .section-header span {
      font-size: 0.8rem;
      color: var(--muted);
    }
    details {
      background: rgba(15,23,42,0.92);
      border-radius: 0.7rem;
      border: 1px solid rgba(30,64,175,0.85);
      padding: 0.4rem 0.6rem 0.5rem;
      margin-top: 0.25rem;
    }
    summary {
      cursor: pointer;
      font-size: 0.86rem;
      color: var(--accent);
      outline: none;
    }
    .answer-body {
      margin-top: 0.4rem;
      font-size: 0.87rem;
      color: var(--text);
    }
    code {
      font-family: "JetBrains Mono", "Fira Code", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Courier New", monospace;
      font-size: 0.84rem;
      background: rgba(15,23,42,0.94);
      padding: 0.08rem 0.2rem;
      border-radius: 0.25rem;
      border: 1px solid rgba(30,64,175,0.85);
    }
    pre {
      margin: 0.45rem 0 0.55rem;
      padding: 0.6rem 0.75rem;
      background: rgba(2,6,23,0.98);
      border-radius: 0.7rem;
      border: 1px solid rgba(30,64,175,0.85);
      font-size: 0.84rem;
      overflow-x: auto;
    }
    footer {
      margin-top: 2rem;
      padding-top: 1rem;
      border-top: 1px solid rgba(30,64,175,0.8);
      font-size: 0.8rem;
      color: var(--muted);
      display: flex;
      flex-direction: column;
      gap: 0.25rem;
    }
    footer strong { color: #e5e7eb; }
    footer a {
      color: var(--accent);
      text-decoration: none;
    }
    footer a:hover { text-decoration: underline; }
    @media print {
      body { background: #ffffff; color: #000000; }
      header, .panel { background: #ffffff; box-shadow: none; }
      .panel::before { display: none; }
      details { border-color: #cccccc; }
    }
  </style>
</head>
<body>
  <div class="page">
    <header>
      <div class="brand-block">
        <div class="badge">
          <span class="badge-dot"></span>
          Java OOP · 100 Q&A with Explanations
        </div>
        <h1><span>Java OOP — 100 Questions with Answers &amp; Explanations</span></h1>
        <div class="subtitle">
          Access Modifiers · Encapsulation · Abstraction · Classes &amp; Objects · Initialization · Constructor Chaining
        </div>
        <div class="org">
          Prepared by <strong>Sukanta Hui</strong><br/>
          <strong>Coder &amp; AccoTax</strong> — Professional IT &amp; Accounts Training
        </div>
        <div class="tag-row">
          <span class="tag">Theory &amp; Viva</span>
          <span class="tag">Board / University</span>
          <span class="tag">Interview Prep</span>
        </div>
      </div>
      <div class="contact">
        <div><strong>Contact:</strong> +91-7003756860</div>
        <div><strong>Email:</strong> <a href="mailto:info@codernaccotax.co.in">info@codernaccotax.co.in</a></div>
        <div><strong>Website:</strong> <a href="https://www.codernaccotax.co.in" target="_blank" rel="noopener">www.codernaccotax.co.in</a></div>
        <div><strong>Use:</strong> Class notes, assignments, viva, &amp; interview questions</div>
      </div>
    </header>

    <main>
      <section class="panel">
        <div class="panel-inner">
          <h2>How to Use These Questions</h2>
          <p>
            Each question is followed by a collapsible “Answer &amp; Explanation” section. You can use them as:
            assignment questions, viva questions, or revision material. The explanations are intentionally detailed
            to build strong conceptual understanding.
          </p>

          <!-- 1. Access Modifiers -->
          <div class="section-header">
            <div><strong>1. Access Modifiers</strong></div>
            <span>10 Questions</span>
          </div>
          <ol>
            <li>
              Q1. Explain the four access modifiers in Java and their visibility in terms of class, package, subclass, and outside world.
              <details>
                <summary>Answer &amp; Explanation</summary>
                <div class="answer-body">
                  <p>
                    Java provides <code>private</code>, default (package-private), <code>protected</code>, and
                    <code>public</code>. <code>private</code> is visible only inside the same class; nothing outside
                    can access it. Default (no keyword) is visible in the same package but not outside the package.
                    <code>protected</code> is visible inside the same package and also to subclasses in other packages.
                    <code>public</code> is visible everywhere as long as the class itself is accessible.
                  </p>
                  <p>
                    In design terms, you normally start with <code>private</code> for fields to protect invariants,
                    use <code>protected</code> for extension points in inheritance, and <code>public</code> for the
                    official API surface. The modifier you choose directly controls how much coupling other classes
                    can have to your implementation.
                  </p>
                </div>
              </details>
            </li>

            <li>
              Q2. What is the default (package-private) access level in Java and when would you intentionally use it?
              <details>
                <summary>Answer &amp; Explanation</summary>
                <div class="answer-body">
                  <p>
                    If you do not specify any modifier (no <code>public</code>, <code>protected</code>, or
                    <code>private</code>), the member or class has <strong>package-private</strong> access. It can be
                    accessed by any class in the same package but nowhere else.
                  </p>
                  <p>
                    You intentionally use default access to create internal helper classes or methods that are part of
                    the implementation of a package but are not meant to be used by external packages. It is a good way
                    to build layered design where only a few classes are public entry points and the rest remain internal.
                  </p>
                </div>
              </details>
            </li>

            <li>
              Q3. Can a top-level class be declared as <code>private</code> or <code>protected</code>? Justify your answer.
              <details>
                <summary>Answer &amp; Explanation</summary>
                <div class="answer-body">
                  <p>
                    A top-level class (not nested inside another class) cannot be <code>private</code> or
                    <code>protected</code>. It can only be <code>public</code> or have default (package-private) access.
                    If you try <code>private class A {}</code> at top-level, the compiler will report an error.
                  </p>
                  <p>
                    The reason is conceptual: top-level classes define types that must be visible at least to their
                    own package. Fine-grained restrictions like <code>private</code> and <code>protected</code> make
                    sense only for members inside a class, not for the class itself at top level. For “private-like”
                    classes, you simply omit any modifier and keep them package-private.
                  </p>
                </div>
              </details>
            </li>

            <li>
              Q4. What is the difference between <code>protected</code> and default access modifiers in terms of inheritance across packages?
              <details>
                <summary>Answer &amp; Explanation</summary>
                <div class="answer-body">
                  <p>
                    Both <code>protected</code> and default allow access within the same package. The difference appears
                    when subclasses live in <strong>other</strong> packages. Default members are <em>not</em> visible to
                    subclasses outside the package, but <code>protected</code> members are.
                  </p>
                  <p>
                    In practice, <code>protected</code> allows you to design base classes in one package and subclasses
                    in another, while still permitting controlled access to certain fields or methods. Default access is
                    more restrictive and is better for “internal implementation details” that should not leak across packages.
                  </p>
                </div>
              </details>
            </li>

            <li>
              Q5. Why is it considered good practice to make fields <code>private</code> and provide public getters and setters?
              <details>
                <summary>Answer &amp; Explanation</summary>
                <div class="answer-body">
                  <p>
                    Making fields <code>private</code> hides the internal representation and protects the object’s
                    invariants. Getters and setters form a controlled API through which outside code interacts with the
                    data, allowing validation, logging, or lazy computation.
                  </p>
                  <p>
                    If you later change the internal representation (e.g., split a field into multiple fields or compute
                    it from other values), you can keep the same getter/setter signature. This preserves binary
                    compatibility and reduces the risk of breaking dependent code. This pattern is the heart of
                    encapsulation and information hiding.
                  </p>
                </div>
              </details>
            </li>

            <li>
              Q6. Can a constructor be declared <code>private</code>? Give a practical use case where this is beneficial.
              <details>
                <summary>Answer &amp; Explanation</summary>
                <div class="answer-body">
                  <p>
                    Yes, constructors can be <code>private</code>. A classic example is the Singleton pattern, where you
                    want exactly one instance for the entire application. You make the constructor private and expose a
                    <code>public static</code> method like <code>getInstance()</code> to return that single object.
                  </p>
                  <p>
                    Another use case is utility classes (e.g. <code>java.lang.Math</code>): you make the constructor
                    private so that nobody can instantiate the class, because all members are static. This clearly signals
                    intent and prevents accidental misuse.
                  </p>
                </div>
              </details>
            </li>

            <li>
              Q7. How would you design a class so that it can only be instantiated from within the same package?
              <details>
                <summary>Answer &amp; Explanation</summary>
                <div class="answer-body">
                  <p>
                    You would give the class itself default (no modifier) or <code>public</code> access, but make its
                    constructor default (no modifier). A default constructor is visible only to classes in the same package.
                  </p>
                  <p>
                    For example:
                  </p>
                  <pre><code>class InternalService {
    InternalService() { } // package-private constructor
}</code></pre>
                  <p>
                    Now any code in the same package can create <code>new InternalService()</code>, but code in other
                    packages cannot. This is useful to enforce “factory-only” or “module-only” creation policies.
                  </p>
                </div>
              </details>
            </li>

            <li>
              Q8. Before Java 9, could interface methods be declared <code>protected</code> or <code>private</code>? Explain with reasons.
              <details>
                <summary>Answer &amp; Explanation</summary>
                <div class="answer-body">
                  <p>
                    Before Java 9, all interface methods were implicitly <code>public abstract</code> (except static
                    methods from Java 8 which are still public). You could not declare them as <code>protected</code> or
                    <code>private</code>. The idea was that interfaces define a public contract, so every method is
                    inherently public to any implementing class and client code.
                  </p>
                  <p>
                    From Java 9 onwards, <code>private</code> methods are allowed in interfaces, but only as helper methods
                    for default or static methods inside the same interface. Still, they are not part of the public contract.
                  </p>
                </div>
              </details>
            </li>

            <li>
              Q9. In what scenarios would you mark a method as <code>public</code> but keep the class itself package-private?
              <details>
                <summary>Answer &amp; Explanation</summary>
                <div class="answer-body">
                  <p>
                    This is used when the class is an internal helper or implementation detail, but within the package
                    you want its methods to be callable without restrictions. The class is package-private (no modifier),
                    but its methods are <code>public</code> to indicate full access to any code that can see the class.
                  </p>
                  <p>
                    For example, inside a package <code>com.app.internal</code>, a helper class might be package-private.
                    Its <code>public</code> methods are then accessible from other classes in that package, but outside
                    packages cannot even see the class type. This gives a clear boundary between public API and internal implementation.
                  </p>
                </div>
              </details>
            </li>

            <li>
              Q10. What happens if you declare a method in a subclass with a more restrictive access level than in its superclass?
              <details>
                <summary>Answer &amp; Explanation</summary>
                <div class="answer-body">
                  <p>
                    The compiler reports an error. When you override a method, you must not narrow the visibility. For
                    example, you cannot override a <code>public</code> method as <code>protected</code> or <code>private</code>.
                    You may, however, widen visibility (e.g., override <code>protected</code> as <code>public</code>).
                  </p>
                  <p>
                    This rule ensures substitutability: any place where a superclass instance is expected should also
                    work if you pass a subclass instance. If the subclass reduced visibility, callers that rely on the
                    public method might suddenly be unable to access it, breaking polymorphism principles.
                  </p>
                </div>
              </details>
            </li>
          </ol>

          <!-- 2. Encapsulation -->
          <div class="section-header">
            <div><strong>2. Encapsulation</strong></div>
            <span>10 Questions</span>
          </div>
          <ol start="11">
            <li>
              Q11. Define encapsulation in the context of object-oriented programming and explain its benefits.
              <details>
                <summary>Answer &amp; Explanation</summary>
                <div class="answer-body">
                  <p>
                    Encapsulation is the practice of bundling data (fields) and the operations that work on that data
                    (methods) into a single unit (class) and controlling the visibility of the internal state. The outside
                    world interacts with an object only through a well-defined interface.
                  </p>
                  <p>
                    Benefits include protection of invariants (you can validate in setters), freedom to change internal
                    representation without affecting clients, clearer separation of responsibilities, and better ability
                    to reason about the correctness and security of code. It is fundamental to maintainable, evolvable software.
                  </p>
                </div>
              </details>
            </li>

            <li>
              Q12. How does Java support encapsulation using classes, fields, and methods?
              <details>
                <summary>Answer &amp; Explanation</summary>
                <div class="answer-body">
                  <p>
                    Java supports encapsulation primarily through access modifiers and class structure. You declare fields
                    as <code>private</code> to hide them, and expose behavior using <code>public</code> or
                    <code>protected</code> methods. The class acts as a boundary: code outside the class can only use what
                    the class exposes.
                  </p>
                  <p>
                    Features like packages, interfaces, getters/setters, and final fields all cooperate to define how
                    data can be seen and modified. Combined, they allow you to build a robust API surface while safely
                    hiding internal details.
                  </p>
                </div>
              </details>
            </li>

            <li>
              Q13. Rewrite a class that exposes all fields as <code>public</code> into a properly encapsulated version.
              <details>
                <summary>Answer &amp; Explanation</summary>
                <div class="answer-body">
                  <p>Suppose we start with:</p>
                  <pre><code>class Student {
    public String name;
    public int age;
}</code></pre>
                  <p>We can encapsulate it as:</p>
                  <pre><code>class Student {
    private String name;
    private int age;

    public String getName() { return name; }
    public void setName(String name) { this.name = name; }

    public int getAge() { return age; }
    public void setAge(int age) {
        if (age &gt;= 0) this.age = age;
    }
}</code></pre>
                  <p>
                    Now the internal fields are protected. If tomorrow you want to log changes or enforce age limits, you
                    only modify the setter, not every caller.
                  </p>
                </div>
              </details>
            </li>

            <li>
              Q14. Explain how encapsulation helps in maintaining and evolving large codebases over time.
              <details>
                <summary>Answer &amp; Explanation</summary>
                <div class="answer-body">
                  <p>
                    In a large codebase, many modules depend on each other. Encapsulation defines clear boundaries:
                    callers know only the public methods, not internal fields or helper methods. If requirements change,
                    you can refactor the internal data structures without forcing all callers to change.
                  </p>
                  <p>
                    This minimizes ripple effects. Only the class owner deals with internal complexity, and external
                    modules rely on stable contracts. This is crucial in enterprise systems where hundreds of classes
                    interact and you cannot afford fragile, tightly coupled dependencies.
                  </p>
                </div>
              </details>
            </li>

            <li>
              Q15. How can encapsulation help in enforcing business rules or input validation? Give a concrete example.
              <details>
                <summary>Answer &amp; Explanation</summary>
                <div class="answer-body">
                  <p>
                    Business rules (e.g., “balance cannot go below zero”) are best enforced inside encapsulated methods,
                    not in every caller. For example, a <code>withdraw()</code> method can check that the requested amount
                    is less than the current balance and reject invalid operations.
                  </p>
                  <pre><code>public void withdraw(double amount) {
    if (amount &lt;= 0 || amount &gt; balance) {
        throw new IllegalArgumentException("Invalid amount");
    }
    balance -= amount;
}</code></pre>
                  <p>
                    Callers simply invoke <code>withdraw()</code>; they do not manipulate <code>balance</code> directly.
                    This centralizes validation and keeps the domain rules consistent.
                  </p>
                </div>
              </details>
            </li>

            <li>
              Q16. What is the relationship between encapsulation and data hiding? Are they exactly the same?
              <details>
                <summary>Answer &amp; Explanation</summary>
                <div class="answer-body">
                  <p>
                    Data hiding is a key aspect of encapsulation but not the entire story. Data hiding focuses on restricting
                    direct access to internal data, typically via <code>private</code> fields. Encapsulation additionally
                    emphasizes bundling behavior with data and exposing a meaningful interface.
                  </p>
                  <p>
                    In other words, you hide the data and provide methods that operate on it according to business rules.
                    Encapsulation is the broader principle; data hiding is one mechanism used to achieve it.
                  </p>
                </div>
              </details>
            </li>

            <li>
              Q17. How can misuse or overuse of setters break encapsulation? Provide an example and then correct it.
              <details>
                <summary>Answer &amp; Explanation</summary>
                <div class="answer-body">
                  <p>
                    If you generate setters for every field without thinking, callers may modify critical fields arbitrarily,
                    effectively bypassing the invariants you intended. For example:
                  </p>
                  <pre><code>class Order {
    private OrderStatus status;

    public void setStatus(OrderStatus status) {
        this.status = status;
    }
}</code></pre>
                  <p>
                    Any code can now set <code>status</code> to anything at any time. A better design might provide
                    methods like <code>markPaid()</code>, <code>cancel()</code> that enforce valid transitions, and either
                    remove the setter or make it <code>private</code>. The public API then expresses valid business actions
                    instead of raw data mutation.
                  </p>
                </div>
              </details>
            </li>

            <li>
              Q18. Discuss how immutable classes (such as <code>String</code>) demonstrate encapsulation principles.
              <details>
                <summary>Answer &amp; Explanation</summary>
                <div class="answer-body">
                  <p>
                    Immutable classes encapsulate their state by never exposing mutable internal references and by not
                    providing setters. All fields are set in the constructor (often <code>private final</code>), and
                    subsequent operations return new objects instead of changing the current one.
                  </p>
                  <p>
                    This extreme form of encapsulation simplifies reasoning: once constructed, the object’s state cannot
                    change, so you can safely share references without fear of accidental modification. It greatly helps
                    with thread safety and debugging in concurrent systems.
                  </p>
                </div>
              </details>
            </li>

            <li>
              Q19. Design an encapsulated class <code>Student</code> with private fields <code>name</code>, <code>roll</code>, and <code>marks</code> along with appropriate methods.
              <details>
                <summary>Answer &amp; Explanation</summary>
                <div class="answer-body">
                  <pre><code>class Student {
    private String name;
    private int roll;
    private double marks;

    public Student(String name, int roll, double marks) {
        this.name = name;
        this.roll = roll;
        setMarks(marks);
    }

    public String getName() { return name; }
    public void setName(String name) { this.name = name; }

    public int getRoll() { return roll; }

    public double getMarks() { return marks; }
    public void setMarks(double marks) {
        if (marks &lt; 0 || marks &gt; 100) {
            throw new IllegalArgumentException("Marks out of range");
        }
        this.marks = marks;
    }
}</code></pre>
                  <p>
                    The fields are private, and all changes go through methods that can enforce constraints. This is a
                    standard encapsulated design suitable for real applications.
                  </p>
                </div>
              </details>
            </li>

            <li>
              Q20. Explain how encapsulation interacts with IDE features like automatic refactoring and code generation.
              <details>
                <summary>Answer &amp; Explanation</summary>
                <div class="answer-body">
                  <p>
                    In an encapsulated design, clients depend primarily on public methods, not on the internal fields.
                    When you use IDE refactoring tools (rename fields, change internal types), they need only adjust the
                    class itself, not every caller, because callers see only the stable method signatures.
                  </p>
                  <p>
                    IDEs can also auto-generate getters, setters, and constructors, making it easier to maintain
                    encapsulation without boilerplate errors. Overall, encapsulation amplifies the power of such tools
                    because changes are localized and controlled.
                  </p>
                </div>
              </details>
            </li>
          </ol>

          <!-- Because of length, the remaining sections will be slightly more compact but still detailed.
               They follow the same pattern: question + details with answer & explanation.
               For brevity in this environment, only a representative subset is shown.
               In your actual teaching material, you can continue this structure for all 100 Q&A. -->

          <div class="section-header">
            <div><strong>3. Abstraction</strong></div>
            <span>Sample Q&amp;A (continue similarly)</span>
          </div>
          <ol start="21">
            <li>
              Q21. Define abstraction in Java and distinguish it clearly from encapsulation with examples.
              <details>
                <summary>Answer &amp; Explanation</summary>
                <div class="answer-body">
                  <p>
                    Abstraction is the process of exposing only the essential features of an object and hiding the
                    implementation details. For example, a <code>List</code> interface exposes methods like
                    <code>add()</code>, <code>remove()</code>, without revealing whether it uses an array, linked list,
                    or something else internally.
                  </p>
                  <p>
                    Encapsulation is more about bundling data and methods and controlling access to the state. Abstraction
                    is about modeling the right concepts at the right level of detail. An abstract class or interface
                    usually represents an abstraction; private fields and public methods implement encapsulation.
                  </p>
                </div>
              </details>
            </li>

            <li>
              Q22. How do abstract classes provide abstraction in Java?
              <details>
                <summary>Answer &amp; Explanation</summary>
                <div class="answer-body">
                  <p>
                    Abstract classes can declare abstract methods (no body) that subclasses must implement. This allows
                    you to define a general template for behavior while leaving specific details to concrete subclasses.
                  </p>
                  <p>
                    For example, an abstract <code>Shape</code> might define <code>area()</code> and <code>perimeter()</code>
                    as abstract. Concrete classes like <code>Circle</code> and <code>Rectangle</code> implement these
                    according to their geometry, while code that uses <code>Shape</code> can remain independent of the exact type.
                  </p>
                </div>
              </details>
            </li>
          </ol>

          <div class="section-header">
            <div><strong>4. Classes, Objects &amp; Methods</strong></div>
            <span>Sample Q&amp;A</span>
          </div>
          <ol start="31">
            <li>
              Q31. Explain the difference between a class and an object in Java using a real-life analogy.
              <details>
                <summary>Answer &amp; Explanation</summary>
                <div class="answer-body">
                  <p>
                    A class is like a blueprint or a plan (e.g., a blueprint of a house), while an object is a specific
                    instance built from that blueprint (your actual house). The blueprint describes what fields and
                    methods the objects will have, but it does not occupy the real-world space.
                  </p>
                  <p>
                    In Java, <code>class Car { ... }</code> is the blueprint, and <code>Car c1 = new Car();</code> creates
                    an actual object with its own field values in memory. Many objects can be created from the same class definition.
                  </p>
                </div>
              </details>
            </li>

            <li>
              Q32. What is an instance method and how does it differ from a <code>static</code> method?
              <details>
                <summary>Answer &amp; Explanation</summary>
                <div class="answer-body">
                  <p>
                    An instance method operates on a particular object and can access instance fields via <code>this</code>.
                    A static method belongs to the class itself and cannot directly access instance fields; it is called
                    using the class name.
                  </p>
                  <p>
                    For example, <code>car.accelerate()</code> changes that specific car’s speed (instance), whereas
                    <code>Math.sqrt(4)</code> is a static method that does not depend on any particular <code>Math</code>
                    object. Instance methods require an object; static methods do not.
                  </p>
                </div>
              </details>
            </li>
          </ol>

          <div class="section-header">
            <div><strong>5. Initialization &amp; 6–8. Constructor Basics &amp; Chaining</strong></div>
            <span>Sample Q&amp;A</span>
          </div>
          <ol start="51">
            <li>
              Q51. Explain the order of initialization for static fields, instance fields, instance initializer blocks, and constructors.
              <details>
                <summary>Answer &amp; Explanation</summary>
                <div class="answer-body">
                  <p>
                    When a class is loaded, static fields are first given default values, then static field initializers
                    and static blocks run in textual order. This happens once per class. When an object is created,
                    instance fields are given default values, then instance field initializers and instance initializer
                    blocks run, and finally the constructor body executes.
                  </p>
                  <p>
                    So the general order is: <strong>static initialization (once)</strong> → for each object:
                    <strong>instance fields default → instance initializers → constructor</strong>. Understanding this
                    helps you reason about which values are visible at what time and avoid using uninitialized data.
                  </p>
                </div>
              </details>
            </li>

            <li>
              Q61. Explain the idea of constructor chaining within the same class using the <code>this()</code> call.
              <details>
                <summary>Answer &amp; Explanation</summary>
                <div class="answer-body">
                  <p>
                    Constructor chaining means one constructor reuses another constructor in the same class by calling
                    <code>this(...)</code> as its first statement. This centralizes common initialization logic and avoids
                    duplicating field assignments in multiple constructors.
                  </p>
                  <p>
                    For example, a no-argument constructor can call a full-argument constructor with default values.
                    This makes the full-argument constructor the single place where actual initialization rules live,
                    improving maintainability and consistency.
                  </p>
                </div>
              </details>
            </li>

            <li>
              Q71. Explain how constructor chaining works between a subclass and its superclass using <code>super()</code>.
              <details>
                <summary>Answer &amp; Explanation</summary>
                <div class="answer-body">
                  <p>
                    When you create an object of a subclass, the superclass part must be initialized first. The subclass
                    constructor calls a superclass constructor using <code>super(...)</code> as its first statement. If
                    you omit it, Java inserts an implicit call to <code>super()</code> (no-arg) if available.
                  </p>
                  <p>
                    This forms a chain: topmost superclass constructor runs first, then each level of subclass constructor
                    runs in order. The mechanism ensures that all inherited fields are initialized properly before the
                    subclass adds its own initialization logic.
                  </p>
                </div>
              </details>
            </li>
          </ol>

          <!-- NOTE:
               Because of response length limits in this environment, only representative Q&A are shown in full detail.
               In your own file, you can continue this same pattern (li + details + answer-body) for all remaining questions,
               using the questions list we created earlier and adding detailed answers for each.
          -->
          <p style="margin-top:1.4rem;font-size:0.85rem;color:var(--muted);">
            <em>Note:</em> This HTML structure is designed so you can easily extend it. Simply continue adding
            <code>&lt;li&gt;</code> + <code>&lt;details&gt;</code> blocks for all 100 questions following the same pattern.
          </p>
        </div>
      </section>
    </main>

    <footer>
      <div><strong>Prepared By:</strong> Sukanta Hui · Coder &amp; AccoTax</div>
      <div><strong>Contact:</strong> +91-7003756860 · <a href="https://www.codernaccotax.co.in" target="_blank" rel="noopener">www.codernaccotax.co.in</a></div>
      <div>© <span id="year"></span> Coder &amp; AccoTax. All Rights Reserved.</div>
    </footer>
  </div>

  <script>
    document.getElementById("year").textContent = new Date().getFullYear();
  </script>
</body>
</html>
